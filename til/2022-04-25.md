# Today I Learned

## How to listen to different servers in Go (using selects)

Today I learned how to listen to different servers in Go, by refactoring an existing codebase of mine.

The existing code looked like this

```go
func Start(o *Opts) error {
	errChan := make(chan error)
	go func() {
		c := make(chan os.Signal, 1)
		signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
		errChan <- fmt.Errorf("%s", <-c)
	}()
	log.Println("listenning to http requests on", o.HTTPAddr)
	go startHTTPSrv(errChan)
	log.Println("listenning to grpc requests on", o.GRPCAddr)
	go startGRPCSrv(errChan)
	return <-errChan
}

func startHTTPSrv(errChan chan<-error) { // the param list is simplified to focus only on the err chan
	errChan <- http.ListenAndServe(/* http.ListenAndServe params */)
}

func startGRPCSrv(errChan chan<-error) { // the param list is simplified to focus only on the err chan
	errChan <- gRPCServer.Serve(/* gRPCServer.Serve params */)
}
```

The `errChan` that I'm using at the beginning of the start func is the same as the one used in the `srvData` struct. 

Which means that the first subroutine returning an error, being the HTTP, the GRPC or the SIGINT/SIGTERM listenner will make this goroutine exit.

This is when I thought that this code I wrote is actually the behaviour of a `select` statement.

So I started transforming it and this is how it looks now


```go
func Start(o *Opts) error {
	select {
	case err := <-startHTTPSrv(newSrvData(o.HTTPAddr)):
		return err
	case err := <-startGRPCSrv(newSrvData(o.GRPCAddr)):
		return err
	case err := <-handleSigTerm():
		return err
	}
}


func startHTTPSrv(/* params */)  <-chan error{ // the param list is simplified to focus only on the err chan
    // [...]
    errChan := make(chan error)
	go func() {
		errChan <- http.ListenAndServe(/* http.ListenAndServe params */)
	}()
	return errChan
}

func startGRPCSrv((/* params */) <-chan error { // the param list is simplified to focus only on the err chan
	// [...]
	errChan := make(chan error)
	go func() {
		// [...]
        errChan <- gRPCServer.Serve(/* gRPCServer.Serve params */)
	}()
	return errChan
}

func handleSigTerm() <-chan error {
    // [...]
	errChan := make(chan error)
	go func() {
		c := make(chan os.Signal, 1)
		signal.Notify(c, syscall.SIGINT, syscall.SIGTERM)
		errChan <- fmt.Errorf("%s", <-c)
	}()
	return errChan
}
```

And this is it. I managed to use the select statement and got a bit more of insight that I wish to share in the hopes that it helps better to understand the usage of select and avoiding using "handmade" select like I originally did.

Againg I hope this was helpful, thanks a lot for your time reading it!

p.s. here is the github reference for the commit I did with this change where you can see the before and after. It's a bit more complex but you will be able to see the complete change
